---
title: C++模板
author: 孙子平
date: 2020-07-03T09:52:39Z
cover: /assets/blog/c++-templates/c++.png
category: C++
tags: [C++, 编程, 泛型]
---

本文是对《C++ Templates》第二版英文原版的学习笔记。部分内容会参考[Walton1128](https://github.com/Walton1128)翻译的[《C++ Templates 第二版》中文翻译](https://github.com/Walton1128/CPP-Templates-2nd--)

<!-- more -->

## 1 函数模板

### 1.1 模板概览

#### 1.1.1 定义模板

模板的形式为`template<...>`，中间省略号代表上逗号`,`分割的模板参数列表。以下是一个简单的例子：

```cpp
template<typename T>
T max(T a, T b)
{
  return a < b ? b : a;
}
```

`typename`关键字用以引入一个类型参数，也可以使用`class`关键字，模板参数除此之外还有非类型模板参数。`T`是一个标识符。这里的`T`必须支持`<`运算和拷贝赋值。

#### 1.1.2 使用模板

通过使用`::max(a, b)`就可以使用改模板函数。使用全局作用域限定符是为了避免与`std::max`冲突。当使用不同类型的参数时，函数会**实例化**（模板参数替换成具体参数的过程）成多个实体。`void`也是一个合法的类型参数。

#### 1.1.3 两阶段翻译

尝试对模板实例化那些不支持的模板需要的操作的类型，会是个编译错误。所以模板经历了两次编译

1. 在定义阶段，忽略模板参数检查模板自身的正确性，可检查的错误包括语法错误、使用未知变量名、未通过且不依赖于模板参数的静态断言；
2. 在实例化阶段，模板再次被检查。

这导致模板在实例化的过程中，编译器必须看到模板的定义。因而模板一般被置于头文件中。注意：某些编译器在定义阶段没有完整地检查。

### 1.2 模板实参推导

模板参数可以只是实际类型的一部分。就像下面那样。

```cpp
template<typename T>
T max(T const& a, T const& b)
{
  return a < b ? b : a;
}
```

传递`int`给模板函数参数则`T`会是`int`。

自动类型转换在模板类型推导中是受限的：

- 当以引用传参的时候，即使是最平凡的转换也不被允许。类型必须精确匹配；
- 当以值传参的时候，只支持`decay`的普通类型转换：忽略cv限定，去除引用，数组转指针，函数转函数指针。如果两个函数参数使用了同一个类型参数，则类型参数decayed的类型必须一致。

如果类型推导失败，可以手动指定类型，就像`max<double>(4, 7.2)`。

类型推导会忽略函数的默认参数。如果要支持设定函数默认参数，需要给模板参数也提供一个默认参数。

### 1.3 多个模板参数

考虑下面的函数：

```cpp
template<typename T1, typename T2>
T1 max(T1 a, T2 b)
{
  return a < b ? b : a;
}
```

我们注意到函数的返回参数被强制转换为了第一个参数的类型，这不符合我们的预期。为此我们有3中解决方案。

#### 1.3.1 返回类型为模板参数

模板参数推导不考虑返回值。由于模板参数的指定必须从左到右依次指定，所以一般将返回类型置于模板其他类型参数之前。

#### 1.3.2 返回类型推导

在C++14中，你可以使用auto关键字。类似`auto max(T1 a, T2 b)`。实际上，对于不带尾随返回类型的auto返回类型，编译器会从函数体中推断类型。这要求函数定义必须存在，且多个返回语句的类型必须一致。

在C++11中，你可以使用尾随返回类型，类似`auto max(T1 a, T2 b) -> decltype(a<b?b:a)`。实际上`decltype(true?b:a)`也可行。为了避免`T1`或`T2`可能为引用类型，我们可以用`typename std::decay<decltype(true?a:b)>::type`。

需要注意的对于`auto`变量的赋值类型始终会被`decay`，`auto`返回值也是如此。

#### 1.3.3 返回共同类型

在C++11中，使用`std::common_type<Types...>::type`可以获得多个类型共同的类型。在C++14中，可以使用`std::common_type_t<Types...>`。`std::common_type`同样decay。

### 1.4 默认模板参数

在C++11之前只有类模板支持默认模板参数。C++11之后，所有类型的模板都支持默认模板参数。默认模板参数可以不是在模板参数的最后。

### 1.5 重载函数模板

函数模板也支持重载。普通函数可以与同名同类型的模板函数共存。只有当模板版本能够产生一个更好的匹配的时候，才会选用模板版本。你也可以通过指定一个空模板参数列表`::max<>(7, 42)`，强制使用模板版本。模板参数推导是不会考虑到自动类型转换的，所以当普通函数能自动类型转换成功的话，而模板函数无法匹配的时候，普通函数就会被选用。
