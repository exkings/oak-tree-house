---
title: 编译原理1：介绍
author: 孙子平
date: 2020-08-04T14:56:23Z
category: 编程
tags: [编程, 编译原理]
series: 编译原理
sidebar:
  - /_posts/2020-08-04-compiler-ch1.html
---

从这个系列开始，我会阅读《编译原理》第二版英文版，并摘录重点内容。希望我能坚持下去。第一章是介绍。

<!-- more -->

本书介绍了如何设计和实现编译器。本章介绍不同形式的语言转换器，概览了编译器的结构，并且讨论了编程语言的趋势和机器架构。

## 1 语言处理器

**编译器**就是从**源语言**转换为对应的**目标语言**的程序。**解释器**是另一种语言处理器，它直接执行源程序。编译器产生的机器语言通常更高效，而解释器通常更方便调试。

一些程序可以辅助编译器：

- **预处理器**：合并文件，展开宏。
- **汇编器**：编译器可以产生更易于调试的汇编语言程序，再由汇编器转换成可重定位机器码。
- **链接器**：大程序通常分开编译，再由链接器把可重定位目标文件和库文件链接成机器码；之后由**加载器**将所有的可执行目标文件载入内存。

## 2 编译器结构

编译器可以大致分为两个部分：

- **分析**：分析部分将源程序转化为中间表示及**符号表**；如果源程序语法不正确或者语义不可靠时，分析部分应当给出提示；通常被称为编译器**前端**。
- **合成**：合成可执行程序；通常被称为编译器**后端**。

接下来的小节会细分编译器的阶段。

### 2.1 词法分析

**词法分析**（lexical analysis）又称**扫描**（scanning）。将字符流分隔成**词素**。对于每个词素，词法分析器产生一个**token**：

$$\langle\textit{token-name}, \textit{attribute-value}\rangle$$

其中*token-name*是一个抽象的符号，*attribute-value*则指向符号表，并且是可选的。

::: tip 词法分析例子

$$\texttt{position = initial + rate * 60}$$

对于上面的代码，会产生下面的一系列词素：

$$\langle\textbf{id},1\rangle~\langle=\rangle~\langle\textbf{id},2\rangle~\langle+\rangle~\langle\textbf{id},3\rangle~\langle*\rangle~\langle 60\rangle$$

词法分析时，空白符就被忽略了。这里数字1、2、3表示符号表中的项，而最后的$\langle 60\rangle$代表常亮，实际上可能是$\langle\textbf{number},4\rangle$，这里作了简化处理。

:::

### 2.2 语法分析

编译器的第二个阶段是**语法分析**（syntax analysis）又称**解析**（parsing）。解析器会从token流中构建出一个树形表示**语法树**。

:::tip 语法分析例子

对于上面的词法分析结果，会产生下面的语法树，这里采用的是我们熟悉的优先级：

```text
      =
    /   \
<id, 1>  +
       /   \
  <id, 2>   *
          /   \
     <id, 3>   60
```

:::

### 2.3 语义分析

**语义分析**（semantic analysis）使用语法树和符号表中的信息检查源代码的语义一致性。它会收集类型信息，保存到语法树或符号表中。

语义分析中很重要的一部分是**类型检查**（type checking）。编译器还会允许一些类型转换，称之为**强制转换**（coercion）。

### 2.4 中间代码生成

在编译成目标代码时，编译器或许会构造处1种或多种中间表示。语法树也是一种中间表示。

**三地址码**是一种典型的中间表示。三地址码由三个操作数构成，它有以下的特点：

- 每一个指令右手边最多只有一个运算，这就使得运算的优先级被表现了出来。
- 编译器会生成一些临时变量。
- 一些指令可能少于三个操作数。

### 2.5 代码优化
